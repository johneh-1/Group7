classdef DoBotControl
    % DOBOTCONTROL Class to control movement of the manipulator
    
    properties (Constant)
        % jointStateSubscriber = rossubscriber('/dobot/state');               % Subscriber to joint states of robot
        % jointService = rossvcclient('/dobot/joint_angles');                 % Service to control joint angles of robot
        % cartService = rossvcclient('/dobot/cartesian');                     % Service to control Cartesian coordinates of robot
    end

    properties
        % jointSubStatus = 0;                                                 % Status of joint state subscriber intialisation
        % jointSrvStatus = 0;                                                 % Status of joint state service initialisation
        % cartSrvStatus = 0;                                                  % Status of Cartesian service initialisation
    end
    
    methods
        function self = DoBotControl()
            % DOBOTCONTROL Define all functions required in the class
            self.GetJointState();
            self.GetCart();
            self.MoveCart(x,y,z);
            self.RotateEndEffector();
        end
    end

    methods (Static)        
        function [base,rearArm,foreArm,ee] = GetJointState()
            % GETJOINTSTATE Return current joint state of DoBot

            % Initialise subscriber to joint states
            jointStateSubscriber = rossubscriber('/dobot_magician/joint_states');
            pause(2);
            currentJointState = jointStateSubscriber.LatestMessage.Position;

            % Store joint states
            base = currentJointState(1);
            rearArm = currentJointState(2);
            foreArm = currentJointState(3);
            ee = currentJointState(4);

            % Print to terminal
            fprintf('Current joint states are [%d,%d,%d,%d',base,rearArm,foreArm,ee);
        end
        
        function [x,y,z] = GetCart()
            % GETCART Return current Cartesian coordinates of end effector

            % Initialise subscriber to end effector pose
            endEffectorPose = rossubscriber('/dobot_magician/end_effector_poses');
            pause(2); %Allow some time for MATLAB to start the subscriber
            currentEndEffectorPoseMsg = endEffectorPose.LatestMessage
            % Extract the position of the end effector from the received message
            currentEndEffectorPosition = [currentEndEffectorPoseMsg.Pose.Position.X,
                                          currentEndEffectorPoseMsg.Pose.Position.Y,
                                          currentEndEffectorPoseMsg.Pose.Position.Z]
            % Extract the orientation of the end effector
            currentEndEffectorQuat = [currentEndEffectorPoseMsg.Pose.Orientation.W,
                                      currentEndEffectorPoseMsg.Pose.Orientation.X,
                                      currentEndEffectorPoseMsg.Pose.Orientation.Y,
                                      currentEndEffectorPoseMsg.Pose.Orientation.Z]
            % Convert from quaternion to euler | Commented out as Quat was 1,0,0,0
            % [roll,pitch,yaw] = quat2eul(currentEndEffectorQuat);
        end
        
        function MoveCart(x,y,z,R,P,Y)
            % MOVECART Move to an end effector pose in Cartesian coordinates
            % Function accepts [x,y,z] point as target with [R,P,Y]
            % rotation.
            % Parameters:
                % [IN] x = x-coordinate in DoBot's frame
                % [IN] y = y-coordinate in DoBot's frame
                % [IN] z = z-coordinate in DoBot's frame
                % [IN] R = roll value in DoBot's frame
                % [IN] P = pitch value in DoBot's frame
                % [IN] Y = yaw value in DoBot's frame

            % Define target position and rotation from input parameters
            endEffectorPosition = [x,y,z];
            endEffectorRotation = [R,P,Y];
            
            % Initialise publisher to target pose
            [targetEndEffectorPub,targetEndEffectorMsg] = rospublisher('/dobot_magician/target_end_effector_pose');
            
            % Populate position message
            targetEndEffectorMsg.Position.X = endEffectorPosition(1);
            targetEndEffectorMsg.Position.Y = endEffectorPosition(2);
            targetEndEffectorMsg.Position.Z = endEffectorPosition(3);
            
            % Populate rotation message
                % @NOTE: Convert R,P,Y to quaternion
            qua = eul2quat(endEffectorRotation);
            targetEndEffectorMsg.Orientation.W = qua(1);
            targetEndEffectorMsg.Orientation.X = qua(2);
            targetEndEffectorMsg.Orientation.Y = qua(3);
            targetEndEffectorMsg.Orientation.Z = qua(4);
            
            % Send the position and rotation message via the publisher
            send(targetEndEffectorPub,targetEndEffectorMsg)
            pause(2);
            fprintf('Moving to [%d,%d,%d]\n',x,y,z);
        end

        function [base,rearArm,foreArm,ee] = RotateEndEffector()
            % ROTATEENDEFFECTOR Return joint state for piece orientation
        end
    end
end

